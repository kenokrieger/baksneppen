"""
Module containing routines for adding specific subplots to a figure and updating
graphs visualising data generated by the ForestFireModel class.
"""
import numpy as np

import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker
from matplotlib.colors import LinearSegmentedColormap

HIST_BINS = np.arange(0, 7, 0.3)
COLOURS = [(0.875, 0.144, 0.105), (0.187, 0, 0), (0.027, 0.457, 0.227)]

PLOTS = {
    "forest": {
        "title": "Forest",
        "xlabel": "",
        "ylabel": ""
    },
    "fitness change": {
        "title": "Minimum fitness over time",
        "xlabel": "time",
        "ylabel": "minimum fitness"
    },
    "avalanche durations": {
        "title": "Histogram of avalanche durations",
        "xlabel": "Duration",
        "ylabel": "Frequency"
    }
}


def add_subplots(figure):
    """
    Add subplots to a figure to visualise the dynamic of the Bak-Sneppen
    evolution model.

    Args:
        figure(matplotlib.figure.Figure): The figure to add the subplots to.

    Returns:
        dict: The created axes.

    """
    axes = dict()
    grid = gridspec.GridSpec(ncols=2, nrows=2, figure=figure)
    axes["forest"] = figure.add_subplot(grid[0:, 0])
    axes["forest"].axis("off")
    axes["fitness change"] = figure.add_subplot(grid[0, 1])
    axes["avalanche durations"] = figure.add_subplot(grid[1, 1])

    for plot in PLOTS:
        axes[plot].set_title(PLOTS[plot]["title"])
        axes[plot].set_xlabel(PLOTS[plot]["xlabel"])
        axes[plot].set_ylabel(PLOTS[plot]["ylabel"])

    axes["avalanche durations"].xaxis.set_major_formatter(
        ticker.FormatStrFormatter("$10^%d$")
    )

    figure.tight_layout()

    return axes


def add_artists(axes):
    """
    Add lines and barplots to a figure and the specified axes.

    Args:
        axes(dict): The axes to add the artists to.

    Returns:
        tuple: The added lines and bars sorted in two dictionaries.

    """
    # all objects that can be updated with the 'set_data'-method
    lines = dict()
    # all objects that can be updated by resizing rectangles
    bars = dict()
    cmap = LinearSegmentedColormap.from_list("forest fire", COLOURS, N=3)
    default_forest = np.random.randint(0, 3, size=(8, 8)) - 1
    lines["forest"] = axes["forest"].imshow(default_forest, cmap=cmap)

    return lines, bars


def update_artists(artists, data):
    """
    Update the artists and axes to display the given data.

    Args:
        artists(tuple): The lines and bars to update.
        data(dict): The data to display on the lines and bars

    Returns:
        None.

    """
    lines, bars = artists
    lines["forest"].set_data(data["forest"])


def update_axes(axes, data):
    """
    Update the limits on the axes to show a pleasing view of the plotted data.

    Args:
        axes(dict): The axes for which the limits shall be updated.
        data(dict): The data which is displayed on the axes.

    Returns:
        None.

    """
    axes["fitness"].set_xlim(-0.3, data["system size"] - 0.7)
    axes["fitness change"].set_xlim(0, data["time"])
    axes["fitness change"].set_ylim(np.min(data["fitness over time"]) - 0.05,
                                    np.max(data["fitness over time"]) + 0.05)
    axes["avalanche durations"].set_ylim(
        0, np.max(np.histogram(data["avalanche durations"], HIST_BINS)[0]) + 1
    )


def clear(lines, bars):
    """
    Reset the lines and bars in the plot to contain no data points.

    Args:
        lines(dict): All the lines to clear.
        bars(dict): All the bars to clear.

    Returns:
        None.

    """
    for line in lines.values():
        line.set_data([])

    for bar in bars.values():
        for rect in bar:
            rect.set_height(0)
